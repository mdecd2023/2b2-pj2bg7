var tipuesearch = {"pages": [{'title': 'About', 'text': '倉儲:https://mdecd2023.github.io/2b2-pj2bg7/content/index.html \n 組長:41023228\xa0rwe1116\xa0 fork 倉儲 \n 組員:41023219 gu811 \n 組員:41023221 41023221 \n 組員:41023222 kolas911205 \n PDF: https://github.com/mdecd2023/2b2-pj2bg7/releases \n', 'tags': '', 'url': 'About.html'}, {'title': '更新團隊網站步驟', 'text': '1.先開起個人USB中的倉儲ipv6 \n 2.在至個人github中的fork倉儲更新成最新版 \n 3.輸入git pull若失敗則有可能PUTTY跑掉重設定即可 \n 4.進行編輯 \n 5.acp \n 6.在至個人fork倉儲Open pull request \n 7.若無法pull request 那就至個人fork在合併最新版本並除錯即可 \n 8.一路同意推送合併到底 \n 9.回到整組倉儲確認上傳己完成 \n \n \n', 'tags': '', 'url': '更新團隊網站步驟.html'}, {'title': 'w9', 'text': '\n', 'tags': '', 'url': 'w9.html'}, {'title': '41023219 足球', 'text': '陳冠佑 \n 心得:剛開始在下載完老師給的程式檔後，還是不知道怎麼雙人連線，好在最後發現在另一台電腦更改ipv4的位置，就能成功連線，非常有成就感。 \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': '41023219 足球.html'}, {'title': '41023221 足球', 'text': '41023221 陳冠翰 心得:剛開始的時候遇到許多困難與錯誤，最後發現是缺失模組導致無法連線，所幸最後有成功解決，成功連線後成就感十足。 \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n<<<<<<< HEAD\n \n', 'tags': '', 'url': '41023221 足球.html'}, {'title': '41023222 足球', 'text': '\n 陳奕倫 \n 心得:一開始不知道該怎麼連線，所一問了組長，他說為了連上主機的ipv4，所以把主機的輸入跟使用者的輸出的防火牆關上。當連線成功的那一剎那，真的太酷啦。 \n \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n', 'tags': '', 'url': '41023222 足球.html'}, {'title': '41023228 足球', 'text': '\n 陳瑨維 \n 心得:一開始，不知道怎麼用，後來,上老師的網站查找怎麼做後，才知道要載入子模組，在控制台打上ipconfig找到主機的ip，輸入到.py檔中，連上組員電腦時，超興奮。 \n \n \n', 'tags': '', 'url': '41023228 足球.html'}, {'title': 'w10', 'text': '', 'tags': '', 'url': 'w10.html'}, {'title': '第一題', 'text': 'What is zmqRemoteAPI, and how does it relate to CoppeliaSim? \n 答 \n 1.zmqRemoteAPI是 ZeroMQ 的遠程 API 通訊協議，用於在不同的程序之間進行通訊和數據傳輸。 \n 2.可使CoppeliaSim進行遠端連接操控。 \n', 'tags': '', 'url': '第一題.html'}, {'title': '第二題', 'text': 'How do you establish a connection between a Python script and CoppeliaSim using zmqRemoteAPI? \n 答 \n python先下載zmq子模組，利用port:23000連接 \n', 'tags': '', 'url': '第二題.html'}, {'title': '第三題', 'text': 'What are some common use cases for zmqRemoteAPI in CoppeliaSim? \n 答 \n 在 CoppeliaSim 中，zmqRemoteAPI 可以用於以下一些常見的應用場景： \n \n \n 控制機器人：zmqRemoteAPI 可以用於控制機器人在 CoppeliaSim中的運動和行為，包括設置關節位置、速度和力矩等參數，控制機器人的運動軌跡和姿態，以及獲取機器人的感測器數據和影像信息等。 \n \n \n 編寫自動化測試：zmqRemoteAPI 可以幫助使用者編寫自動化測試脚本，測試機器人和其他物體的運動和行為，並驗證機器人的控制算法和程序的正確性。 \n \n \n 設計自主導航系統：zmqRemoteAPI 可以用於設計自主導航系統，通過控制機器人的運動和行為來實現自主導航，並在 CoppeliaSim 中進行仿真測試。 \n \n \n 進行物體檢測和跟蹤：zmqRemoteAPI 可以用於設計物體檢測和跟蹤系統，通過獲取 CoppeliaSim 中的影像數據和感測器數據來實現物體檢測和跟蹤功能。 \n \n \n zmqRemoteAPI 可以幫助使用者更加靈活方便控制 CoppeliaSim 中的機器人和物體。 \n', 'tags': '', 'url': '第三題.html'}, {'title': '第四題', 'text': 'What are the advantages and disadvantages of using zmqRemoteAPI compared to other methods of communication between Python and CoppeliaSim? \n 答 \n 優點： \n \n 快速和高效：zmqRemoteAPI使用ZeroMQ消息庫，以其快速和高效的消息傳遞能力而聞名。 \n 易於使用：zmqRemoteAPI是一個簡單易用的API，提供了一系列函數，可從Python腳本中控制模擬。 \n 跨語言支持：zmqRemoteAPI是一種跨語言協議，因此您可以使用任何支持ZeroMQ的編程語言。 \n 支持多個連接：zmqRemoteAPI支持多個連接，因此您可以將多個客戶端連接到單個CoppeliaSim實例。 \n \n 缺點： \n \n 功能受限：儘管zmqRemoteAPI提供了一系列函數來控制CoppeliaSim，但與其他通信方法（如ROS或Python的Coppeliasim庫）相比，其功能受限。 \n 上手難度高：zmqRemoteAPI需要一些ZeroMQ和socket編程的知識，這對於新手用戶來說可能不太容易使用。 \n 可能出現錯誤：如果通信未正確配置，zmqRemoteAPI容易出現錯誤，這可能會導致消息丟失或模擬停滯等問題。 \n 彈性較小：與其他通信方法相比，zmqRemoteAPI的自定義彈性較小，因為它依賴於預定義的一組函數。 \n \n', 'tags': '', 'url': '第四題.html'}, {'title': '第五題', 'text': 'Can you give an example of a project or task that you could complete using zmqRemoteAPI in CoppeliaSim? \n 答 \n 1.開啟 CoppeliaSim \n 2.選取場景 \n 3.尋找主機IP位置 \n 4.更改城市中的連結為至於上步驟之主機位置 \n 5.開始連結 \n', 'tags': '', 'url': '第五題.html'}, {'title': '小組工作分配', 'text': '41023219: 設計零件導入場景。 \n 41023221: 討論查詢程式。 \n 41023222: 場景建設。 \n 41023228: 討論與設計程式，製作亂數。 \n', 'tags': '', 'url': '小組工作分配.html'}, {'title': '2b網站順序亂數', 'text': '\n \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n \n', 'tags': '', 'url': '2b網站順序亂數.html'}, {'title': 'w11', 'text': '足球場景 \n 計分系統 \n 控制系統 \n 單機計分與控制 \n 完整版 \n \n', 'tags': '', 'url': 'w11.html'}, {'title': '41023219', 'text': '足球場景 \n 計分系統 \n 控制系統 \n 單機計分與控制 \n 完整版 \n \n \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n 自評分數:60 \n 過程:修改感測器的程式檔，分別定義四台機器人為bubbleRob1、2、3、4,然後修改細項，讓感測器能分辨球與機器人。 \n 心得:這次的分組讓我學會了如何解決上傳合併的衝突，然後在修改計分系統的時候遇到了一些問題，很感謝組長的協助。 \n', 'tags': '', 'url': '41023219.html'}, {'title': '41023221', 'text': '足球場景 \n 計分系統 \n 控制系統 \n 單機計分與控制 \n 完整版 \n 過程:先編輯計分表把它區分成四大部分，分別為紅方得分十位數、紅方得分個位數、綠方十位數以及綠方個位數，再把四大部分的每個零件編號，以利於後面進行變色，利用個別零件的變色，來達到顯示分數，最後把它合併進場景再進行程式代碼除錯(因為是分開寫完再合併的會有衝突)，主要錯誤在於感應器，把名稱對上就行。 \n \n  接下來將 mp4 檔案從 downloads 目錄取出  \n \n \n 自評:遇到需多困境與難題，所幸在與同學的討論中取得成功 \n 自評分數:64 \n', 'tags': '', 'url': '41023221.html'}, {'title': '41023222', 'text': '足球場景 \n 計分系統 \n 控制系統 \n 單機計分與控制 \n 完整版 \n 自評: \n \xa0 \xa0 感謝組員和組長耐心的在旁邊指導，讓我能清楚知道我該做甚麼適和該怎麼做，線終於跟上進度了，沒有隊友的幫助，我還真不知該怎麼辦，但最後能完成還是很有成就感。 \n 自評分數: \n \xa0 \xa0 \xa0 60分 \n 過程 : 使用onshape繪製然後匯出.stl，再用coppeliaSim.exe打開檔案放置 \n \n \n', 'tags': '', 'url': '41023222.html'}, {'title': '41023228', 'text': '足球場景 \n 計分系統 \n 控制系統 \n 單機計分與控制 \n 完整版 \n \n 過程: \n \xa0 \xa0 \xa0 做出四隻機器人，更改按鍵,在場景內加入code讓單機時有計分系統，在場景中加入七段顯示器，得分時變色顯示分數，讓玩家在瀏覽器中可以看到分數。 \n 自評: \n \xa0 \xa0 \xa0 pj2中負責做出PDF報告，w10做出亂數、w11主要做控制系統，輔助組員做單機顯示分數及瀏覽器也可以看到分數的實體顯示，pj2結束後持續幫助組員及其他組別解決問題 \n 自評分數: \n \xa0 \xa0 \xa0 65分 \n', 'tags': '', 'url': '41023228.html'}, {'title': 'group', 'text': '41023219:resume  ( repo ) ,  football  ( repo ),  pj1  ( repo ),  pj2  ( repo ),  pj3  ( repo ) \n 41023221:resume ( 倉儲 ),  football  ( 倉儲 ),  pj1bg22  ( 倉儲 ),  pj2bg7 ( 倉儲 ),  pj3bg4  ( 倉儲 ) \n 41023222:resume (repo), football (repo),  pj1  ( repo ), pj2 ( repo ), pj3 (repo) \n 41023228: 倉儲  resume, 倉儲   football , 倉儲   pj1 , 倉儲   pj2 , 倉儲  pj3 \n \n \n \n', 'tags': '', 'url': 'group.html'}, {'title': 'Brython', 'text': 'https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation (Python 採 4 個 Spaces 縮排, 以界定執行範圍) \n Variables ( Python Keywords ) \n Comments (# 單行註解, 三個單引號或三個雙引號標註多行註解) \n Numbers  (整數 int(), 浮點數 float()) \n Strings  (字串) \n print (Python 內建函式,  print()  函式) \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris Rotating Block \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n \n', 'tags': '', 'url': 'Brython.html'}, {'title': 'Brython_ex2', 'text': 'This code uses the Euler method to approximate the solution to the ODE dy/dx = x - y with an initial condition of y0 = 1.0. The solution is calculated for a range of x values from 0 to 5. \n \n \n \n \n \n \n Solve ODE: \n from browser import document\n\ndef dy_dx(y, x):\n    return x - y\n\nx_start = 0\nx_end = 5\nn_points = 100\nx = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]\ny0 = 1.0\nh = x[1] - x[0]\ny = [y0]\nfor i in range(1, len(x)):\n    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))\n\n# Create a new paragraph element and set its text content to the solution\np = document.createElement(\'p\')\np.textContent = f"The solution to the ODE is: {y}"\n\n# Append the paragraph element to the body of the webpage\ndocument.body.appendChild(p) \n \n \n \n \n \n Brython environment and  Plotly.js : \n <script src="./../cmsimde/static/brython.js"></script>\n<script src="./../cmsimde/static/brython_stdlib.js"></script>\n<script>// <![CDATA[\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\']});\n}\n// ]]></script>\n<p id="brython_div"></p> \n Brython programe with Plotly.js: \n from browser import document, window\n\ndef dy_dx(y, x):\n    return x - y\n\nx_start = 0\nx_end = 5\nn_points = 100\nx = [x_start + i * (x_end - x_start) / (n_points - 1) for i in range(n_points)]\ny0 = 1.0\nh = x[1] - x[0]\ny = [y0]\nfor i in range(1, len(x)):\n    y.append(y[-1] + h * dy_dx(y[-1], x[i-1]))\n\n# Create a new div element to hold the plot\n#plot_div = document.createElement(\'div\')\n#plot_div.id = \'plot\'\n#document.body.appendChild(plot_div)\nplot_div = document["brython_div"]\n\n# Plot the solution using plotly.js\ndata = [{\'x\': x, \'y\': y}]\nwindow.Plotly.newPlot(\'brython_div\', data) \n This code defines a function dy_dx that represents the mass-spring-damper ordinary differential equation. The Euler method is used to solve this equation for a range of x values from 0 to 20 with initial conditions of y0 = [1.0, 0.0]. The solution is then plotted on the webpage using  plotly.js . \n \n \n \n \n This code defines a function dy_dx that represents the mass-spring-damper system with a PID controller. The gains of the PID controller are set to Kp = 10.0, Ki = 1.0, and Kd = 0.5. The Euler method is used to solve this system of equations for a range of x values from 0 to 20 with initial conditions of y0 = [0.0, 0.0, 0.0, 0.0]. The response of the system is then plotted on the webpage using  plotly.js . \n \n \n \n \n \n \n \n \n \n \n \n \n \n STL part viewer \n \n \n \n \n Using  sine-cosine algorithm  to optimize with constraints in Brython: \n <!DOCTYPE html>\n<html>\n<head>\n    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython_stdlib"></script>\n</head>\n<body onload="brython()">\n\n<div id="output"></div>\n\n<script type="text/python">\nfrom browser import document\nfrom random import random, uniform\nfrom math import sin, cos, pi\n\n# Define the objective function\ndef objective_function(x):\n    return x[0]**2 + x[1]**2\n\n# Define the constraint functions\ndef constraint1(x):\n    return x[0] + x[1] - 2\n\ndef constraint2(x):\n    return 1 - x[0] - x[1]\n\n# Define the penalty function\ndef penalty_function(x):\n    penalty = 0\n    if constraint1(x) > 0:\n        penalty += constraint1(x)\n    if constraint2(x) > 0:\n        penalty += constraint2(x)\n    return penalty\n\n# Define the fitness function\ndef fitness_function(x):\n    return objective_function(x) + penalty_function(x)\n\n# Define the sine cosine algorithm\ndef sine_cosine_algorithm(fitness_function, dimension, lower_bound, upper_bound, population_size, max_iterations):\n    # Initialize the population\n    population = [[uniform(lower_bound, upper_bound) for _ in range(dimension)] for _ in range(population_size)]\n    population_fitness = [fitness_function(individual) for individual in population]\n\n    # Initialize the best solution\n    best_solution = population[0]\n    best_fitness = population_fitness[0]\n\n    # Main loop of the algorithm\n    for iteration in range(max_iterations):\n        # Calculate the value of a and r1\n        a = 2 - iteration * (2 / max_iterations)\n        r1 = 2 * pi * random()\n\n        # Update the population\n        for i in range(population_size):\n            # Calculate the value of r2, r3 and r4\n            r2 = 2 * random()\n            r3 = 2 * random()\n            r4 = random()\n\n            # Update the individual\n            for j in range(dimension):\n                if r4 < 0.5:\n                    population[i][j] += r1 * sin(r2) * abs(r3 * best_solution[j] - population[i][j])\n                else:\n                    population[i][j] += r1 * cos(r2) * abs(r3 * best_solution[j] - population[i][j])\n\n                # Make sure the individual is within the bounds\n                if population[i][j] < lower_bound:\n                    population[i][j] = lower_bound\n                elif population[i][j] > upper_bound:\n                    population[i][j] = upper_bound\n\n            # Calculate the fitness of the individual\n            population_fitness[i] = fitness_function(population[i])\n\n            # Update the best solution\n            if population_fitness[i] < best_fitness:\n                best_solution = population[i]\n                best_fitness = population_fitness[i]\n\n        # Print the current iteration and best fitness\n        print(f\'Iteration: {iteration + 1}, Best Fitness: {best_fitness:.6f}\')\n\n    return best_solution\n\n# Run the sine cosine algorithm to solve the optimization problem with constraints\nbest_solution = sine_cosine_algorithm(fitness_function, dimension=2, lower_bound=-10, upper_bound=10, population_size=50, max_iterations=100)\n\n# Print the result\noutput_div = document[\'output\']\noutput_div.text = f\'Best Solution: {best_solution}\'\n</script>\n\n<script src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython"></script>\n</body>\n</html> \n Plot the result by using  plotly.js : \n <!DOCTYPE html>\n<html>\n<head>\n    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython_stdlib"></script>\n    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>\n</head>\n<body onload="brython()">\n\n<div id="output"></div>\n<div id="plot"></div>\n\n<script type="text/python">\nfrom browser import document\nfrom random import random, uniform\nfrom math import sin, cos, pi\n\n# Define the objective function\ndef objective_function(x):\n    return x[0]**2 + x[1]**2\n\n# Define the constraint functions\ndef constraint1(x):\n    return x[0] + x[1] - 2\n\ndef constraint2(x):\n    return 1 - x[0] - x[1]\n\n# Define the penalty function\ndef penalty_function(x):\n    penalty = 0\n    if constraint1(x) > 0:\n        penalty += constraint1(x)\n    if constraint2(x) > 0:\n        penalty += constraint2(x)\n    return penalty\n\n# Define the fitness function\ndef fitness_function(x):\n    return objective_function(x) + penalty_function(x)\n\n# Define the sine cosine algorithm\ndef sine_cosine_algorithm(fitness_function, dimension, lower_bound, upper_bound, population_size, max_iterations):\n    # Initialize the population\n    population = [[uniform(lower_bound, upper_bound) for _ in range(dimension)] for _ in range(population_size)]\n    population_fitness = [fitness_function(individual) for individual in population]\n\n    # Initialize the best solution\n    best_solution = population[0]\n    best_fitness = population_fitness[0]\n\n    # Main loop of the algorithm\n    for iteration in range(max_iterations):\n        # Calculate the value of a and r1\n        a = 2 - iteration * (2 / max_iterations)\n        r1 = 2 * pi * random()\n\n        # Update the population\n        for i in range(population_size):\n            # Calculate the value of r2, r3 and r4\n            r2 = 2 * random()\n            r3 = 2 * random()\n            r4 = random()\n\n            # Update the individual\n            for j in range(dimension):\n                if r4 < 0.5:\n                    population[i][j] += r1 * sin(r2) * abs(r3 * best_solution[j] - population[i][j])\n                else:\n                    population[i][j] += r1 * cos(r2) * abs(r3 * best_solution[j] - population[i][j])\n\n                # Make sure the individual is within the bounds\n                if population[i][j] < lower_bound:\n                    population[i][j] = lower_bound\n                elif population[i][j] > upper_bound:\n                    population[i][j] = upper_bound\n\n            # Calculate the fitness of the individual\n            population_fitness[i] = fitness_function(population[i])\n\n            # Update the best solution\n            if population_fitness[i] < best_fitness:\n                best_solution = population[i]\n                best_fitness = population_fitness[i]\n\n        # Print the current iteration and best fitness\n        print(f\'Iteration: {iteration + 1}, Best Fitness: {best_fitness:.6f}\')\n\n    return best_solution\n\n# Run the sine cosine algorithm to solve the optimization problem with constraints\nbest_solution = sine_cosine_algorithm(fitness_function, dimension=2, lower_bound=-10, upper_bound=10, population_size=50, max_iterations=100)\n\n# Print the result\noutput_div = document[\'output\']\noutput_div.text = f\'Best Solution: {best_solution}\'\n\n# Plot the result using Plotly.js\ndata = [\n    {\n        \'x\': [best_solution[0]],\n        \'y\': [best_solution[1]],\n        \'mode\': \'markers\',\n        \'marker\': {\'size\': 12},\n        \'name\': \'Best Solution\'\n    }\n]\n\nlayout = {\n    \'xaxis\': {\'range\': [-10, 10]},\n    \'yaxis\': {\'range\': [-10, 10]},\n}\n\nPlotly.newPlot(\'plot\', data, layout)\n</script>\n\n<script src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython"></script>\n</body>\n</html> \n \n the current iteration and best fitness print(f\'Iteration: {iteration + 1}, Best Fitness: {best_fitness:.6f}\') return best_solution # Run the sine cosine algorithm to solve the optimization problem with constraints best_solution = sine_cosine_algorithm(fitness_function, dimension=2, lower_bound=-10, upper_bound=10, population_size=50, max_iterations=100) # Print the result output_div = document[\'output\'] output_div.text = f\'Best Solution: {best_solution}\' # Plot the result using Plotly.js data = [ { \'x\': [best_solution[0]], \'y\': [best_solution[1]], \'mode\': \'markers\', \'marker\': {\'size\': 12}, \'name\': \'Best Solution\' } ] layout = { \'xaxis\': {\'range\': [-10, 10]}, \'yaxis\': {\'range\': [-10, 10]}, } Plotly.newPlot(\'plot\', data, layout) </script> <script src="https://cdn.jsdelivr.net/npm/brython@3/dist/brython"></script> </body> </html> \n', 'tags': '', 'url': 'Brython_ex2.html'}]};